\begin{DoxyAuthor}{Auteur}
LKU
\end{DoxyAuthor}
\hypertarget{index_Préambule}{}\doxysection{Préambule}\label{index_Préambule}
Dans le cadre de l’atelier de 31-\/Programmation OO enseigné par Jérôme Connus, nous devons réaliser un jeu vidéeo pour testé nos connaissance en c++. Le code sera par la suite évaluée. \hypertarget{index_intro_sec}{}\doxysection{Introduction}\label{index_intro_sec}
Amongus-\/\+Jumper est un jeu vidéo dit Platformer. Un Platformer est un sous-\/genre du jeux vidéo d’action qui consiste à contrôler un personnage qui doit sauter sur des plateformes dans les airs et éviter des obstacles. vous pouvez retrouvé le code du joueur dans \mbox{\hyperlink{class_character}{Character}} ainsi que dans le \mbox{\hyperlink{class_game_core}{Game\+Core}}. \hypertarget{index_Entité}{}\doxysection{Entité}\label{index_Entité}
les Sprites ayant une vélocité, pouvant être détruit ou étant soumis à la gravité sont considérés comme vivants, et sont donc des entités. Actuellement, il existe trois classes qui découlent de la classe \mbox{\hyperlink{class_entity}{Entity}}. Les classes \mbox{\hyperlink{class_bulio}{Bulio}}, \mbox{\hyperlink{class_character}{Character}} et \mbox{\hyperlink{class_caisse_amovible}{Caisse\+Amovible}} gérant respectivement les ennemis, le joueur et les caisses en bois. \hypertarget{index_Gestion}{}\doxysection{des collisions}\label{index_Gestion}
Les collisions sont détectées et utilisées par les entités du jeu. La plupart des entités comme les caisses gèrent leur collision par leur Tick\+Handler() (qui est activé dans le tick() du gamecore). Le Tick\+Handler() va s’occuper des collisions (selon le type d’entité) par anticipation ou par collision actuelle. \hypertarget{index_Collision}{}\doxysubsection{par anticipation}\label{index_Collision}
La collision par anticipation est utilisée essentiellement pour la gestion de la gravité. Effectivement, on en a besoin pour savoir à l’avance à quel moment l’entité devra être attirée par le bas ou non. Pour ce faire, on utilise la vélocité de l’entité pour savoir si elle va entrer en collision avec la scène ou un élément de celle-\/ci. On utilise la fonction next\+Collision() du Tick\+Handler\+Entity. \hypertarget{index_Collision}{}\doxysubsection{par anticipation}\label{index_Collision}
Ce type de collision se produit lors d’un contact direct entre l’entité et un autre sprite. Par exemple, pour savoir si une caisse doit se déplacer, on vérifie si le joueur touche la caisse. \hypertarget{index_Collision}{}\doxysubsection{par anticipation}\label{index_Collision}
Dans ce jeu, on a besoin de savoir de quel côté une entité entre en contact avec un sprite. Pour ce faire, les entités utilisent la méthode get\+Collision\+Locate() qui récupère les valeurs de la fonction intersected() mise à dispositions par Qt. Celle-\/ci renvoie l\textquotesingle{}intersection entre les deux rectangles donnés. En l’occurrence, on utilise la bouding Box des deux sprites pour ensuite localiser la zone en contact. \hypertarget{index_Annexes}{}\doxysection{Annexes}\label{index_Annexes}
Vous retrouvez plus d\textquotesingle{}informations dans les 3 PDF dans répertoire doc. 